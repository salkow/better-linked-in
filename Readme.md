# BackEnd

To backend κομμάτι έγινε με τη χρήση του Java SpringBoot και για τη βάση δεδομένων χρησιμοποιήθηκε το MySql.

Για να τρέξει η βάση απαιτείται να υπάρχει μια βάση **betterlinkedin** με **όνομα χρήστη tedi** και **κωδικό tedi2021**. Το hibernate δημιουργεί όλους τους απαραίτητους πίνακες αυτόματα και τρέχει στη διεύθυνση **https://localhost:8084**.

Κατά την πρώτη εκτέλεση του κώδικα του backend(άδεια βάση δεδομένων), προστίθεται ένας χρήστης με δικαιώματα *admin*, ο οποίος ως πρώτος χρήστης στην βάση, θα έχει το id 1.

Χρησιμοποιώ το Spring Security για την διασφάλιση του backend μέρους του site, το οποίο σημαίνει ότι η πρόσβαση σε όλα τα endpoints εκτός του **/perform_login** και του **/api/v1/registration**, επιτρέπεται μόνο σε εξουσιοδοτημένους χρήστες. Η εξουσιοδότηση γίνεται μέσω ενός JWT token το οποίο δίνεται στο χρήστη μετά από ένα επιτυχημένο login request και το οποίο ο χρήστης έπειτα έχει σε κάθε request του προς το server στο header *Authorization* με περιεχόμενο *"Bearer JWTToken"*. Το login και το registration γίνονται με ένα POST request στην κατάλληλη διεύθυνση και το σώμα του είναι σε μορφή form data. Στο login επιστρέφω ένα JSON με το JWTToken και το ένα String που είναι "ADMIN" ή "USER", ανάλογα με το ρόλο του χρήστη. Στο registration, η φωτογραφία σώζεται τοπικά στο φάκελο images, μέσα σε ένα υποφάκελο με όνομα το id του χρήστη.

Αν ο χρήστης είναι admin, υπάρχει το **/api/v1/users** που επιστρέφει ένα JSON με τα απαραίτητα στοιχεία για όλους τους χρήστες.

Αν ο χρήστης θέλει τα δικά του στοιχεία, χρειάζεται ένα GET στο **/api/v1/user**, ενώ αν θέλει τα στοιχεία κάποιου άλλου χρήστη, τότε με ένα GET στο **/api/v1/user/{id}**, όπου id το id του χρήστη. Επίσης, αν θέλει το δικό του id κάνει ένα GET στο **/api/v1/id**, ενώ αν θέλει το email του, κάνει ένα GET στο **/api/v1/email**. Επιπλέον, για το δικό του όνομα χρειάζεται ένα GET στο **/api/v1/name** και για το όνομα κάποιου άλλου χρήστη, ένα GET στο **/api/v1/name/{id}**, όπου id το id του άλλου χρήστη.

Για να ενημερώσει το email του, στέλνει ένα PUT request στο **/api/v1/email** και στο σώμα απλά ένα String και ομοίως για να ενημερώσει τον κωδικό του με ένα PUT στο **/api/v1/password**.

Η ενημέρωση της εμπειρίας, της εκπαίδευσης και των δυνατοτήτων του γίνεται μέσω ενός PUT request στα **/api/v1/experience**, **/api/v1/education**, **/api/v1/skills** αντίστοιχα, με ένα JSON στο σώμα του με το κείμενο και το αν είναι ορατό σε άλλους.

Ο χρήστης στέλνει αίτημα φιλίας σε άλλο χρήστη με ένα PUT στο **/api/v1/friendRequest/{receiverid}**, όπου receiverid το id του λήπτη και για να απαντήσει σε ένα αίτημα του χρήστη με id senderid, στέλνει ένα PUT στο **/api/v1/friendRequestResponse/{senderid}** και στο σώμα ένα wrapper JSON με ένα boolean για την απάντηση στο request. Μπορεί επίσης να δει τα αιτήματα που έχει στείλει και λάβει με ένα GET στα **/api/v1/friendRequestsSent** και **/api/v1/friendRequestsReceived** αντίστοιχα. Έχει επιπλέον τη δυνατότητα να δει όλους τους φίλους του σε λίστα με GET στο **/api/v1/friends** και να ελέγξει αν είναι φίλος με τον χρήστη με id, με GET στο **/api/v1/checkFriend/{id}**.

Για να πάρει τη λίστα των επαφών του, κάνει ένα GET request στο **/api/v1/contacts**. Η αποστολή μηνύματος σε χρήστη με τον οποίο είναι επαφή και έχει id receiverId γίνεται μέσω ενός PUT στο **api/v1/sendMessage/{receiverId}**, που έχει στο σώμα ένα wrapper JSON για το κείμενο του μηνύματος και για να πάρει όλη τη συνομιλία με τον χρήστη με receiverId στέλνει ένα GET στο **api/v1/messages/{receiverId}**. Έχει και τη δυνατότητα να πάρει τα μηνύματα με τον τελευταίο χρήστη που έχει επικοινωνήσει με GET στο **api/v1/messages** και να πάρει το id της τελευταίας επαφής με την οποία επικοινώνησε με ένα GET στο **/api/v1/lastContactId**. 

Υπάρχει η δυνατότητα να ανεβάσει ένα post, το οποίο μπορεί να έχει κείμενο και φωτογραφία ή ηχητικό  ή βίντεο(μπορεί και μόνο κείμενο ή μόνο έναν τύπο media), στέλνοντας ένα POST request στο **/api/v1/post** με τα δεδομένα σε μορφή form data. Ο χρήστης μπορεί να πάρει μια λίστα από τα posts που έχει κάνει ο ίδιος με ένα GET στο **/api/v1/myPosts** και μία λίστα από τα δικά του posts, των φίλων του και αυτάμε τα οποία έχουν αλληλεπιδράσει οι φίλοι του σε χρονική σειρά από το πιο πρόσφατο με ένα GET στο **/api/v1/posts**. Ο χρήστης σχολιάζει σε ένα post με id post_id στέλνοντας ένα PUT request στο **/api/v1/comment/{post_id}** με ένα wrapper JSON ενός String στο σώμα του και μπορεί να πάρει τα σχόλια ενός post με ένα GET στο **/api/v1/comment/{post_id}**. Ομοίως κάνει like σε ένα post με id post_id στέλνοντας ένα PUT request στο **/api/v1/like/{post_id}** και μπορεί να πάρει λίστα των likes που έχουν γίνει σε αυτό με ένα GET στο **/api/v1/postLikes/{post_id}**.

Ένα GET στο **/api/v1/notifications** θα επιστρέψει τις ειδοποιήσεις του χρήστη για comments ή likes άλλων χρηστών σε post του.

Ο χρήστης μπορεί να ανεβάσει μία αγγελία με ένα POST στο **/api/v1/advert** με ένα JSON στο σώμα του με τις πληροφορίες της αγγελίας και να κάνει αίτηση σε μία αγγελία με id advert_id στέλνοντας ένα PUT στο **/api/v1/apply/{advert_id}**. Επίσης, μπορεί να πάρει μια λίστα από τις αγγελίες του με ένα GET στο **/api/v1/myAdverts** και μια λίστα από αγγελίες άλλων στις οποίες έχει *τουλάχιστον* μία από τις απαιτούμενες δυνατότητες με ένα GET στο **/api/v1/adverts**.

Τέλος, έχει τη δυνατότητα να ψάξει χρήστες με βάση το όνομα τους με ένα POST στο **/api/v1/search**, που επιστρέφει λίστα από JSON χρηστών. Η αναζήτηση είναι **case insensitive**, αναγνωρίζει ακόμα και το να έχεις ένα substring του ονόματος και είναι *SQL inject safe*, καθώς δεν χρησιμοποιείται string concatenation για την είσοδο του χρήστη στο SQL query, αλλά είναι parameterized.

# Επίλογος

Ένα ακόμα πρόβλημα που μας δυσκόλεψε ήταν το να εισάγουμε το SSL certificate στους διάφορους browser. Για την όλη διαδικασία ακολουθήσαμε τις οδηγίες που δώθηκαν και στο μάθημα, αλλά δεν άφηνε να εισάγω το certificate στα authorities(σε firefox και chromium) γιατί δεν ήταν root certificate ενώ το είχα προσθέσει στον κατάλληλο κατάλογο των Linux. Αυτό που βρήκα είναι ότι οι browsers δεν χρησιμοποιούν το certificate store των συστημάτων, αλλά δικά τους. Η λύση που βρήκα ήταν ένα bash script, το οποίο με την εντολή certutil τροποποιεί τα certificate stores cert8.db(Firefox) και cert9.db(Chromium & Chrome), αφού τα εντοπίσει.




